# 基础

## TCP/IP网络模型

* 应用层: 工作在操作系统中的用户态, 专注于为用户提供应用功能, 而不用去关心如何传输数据.
* 传输层: 进程间数据传输.
* 网络层: 主机间数据传输, 分组、寻址、路由.
* 链路层: 将数据包组装成以太网帧, 在单一链路上发送数据.

## 访问网页全过程

首先需要自上而下的展开:

在输入网页后, 浏览器会对URL进行解析, 并封装对应的GET请求, 委托操作系统发送.

委托操作系统发送HTTP消息需要提供服务器IP地址, 所以需要进行**DNS解析**.

首先DNS服务器是分层级的: 根域名服务器(.) -> 顶级域名服务器(.cn) -> 权威域名服务器(axlis.cn)

根域名服务器的地址存储在了所有的域名服务器中, 这样就可以从根域名服务器开始查找任意域名的IP地址了.

查询过程理论上有两种方式: 递归和迭代.

一般流程是客户端向本地DNS服务器查询IP地址, 本地DNS服务器会采用迭代的方式从上层域名服务器查找IP地址, 并构建缓存.

当然客户端的浏览器、操作系统都会缓存IP地址映射, 在hosts文件中也可以配置IP地址映射.

当查找到IP地址后就会将HTTP报文交给**TCP**连接进行发送.

提到TCP就得先从TCP Header说起, TCP Header中主要包含: **端口、序列号、状态位、窗口大小、校验和**.

TCP的三大特性有**面向连接、可靠传输、字节流**:

* 其中面向连接与Header中端口、状态位、序列号有关, 主要涉及三次握手和四次挥手.
* 其中可靠传输与Header中序列号有关, 主要涉及超时重传、快速重传.
* 其中字节流与Header中序列号、窗口大小有关，主要涉及滑动窗口、拥塞控制.

然后操作系统就会为HTTP加上TCP Header并交给IP层处理. 如果HTTP报文过大, TCP还会将HTTP报文拆分后在交给IP层处理.

IP Header中主要包含: IP地址、协议号、TTL、校验和, 路由器完成路由需要解析IP Header中的数据.

然后操作系统就会为IP报文加上MAC地址, 发送方的MAC直接从网卡中获取, 接收方的MAC地址通过广播的方式获取 (使用ARP协议).

然后报文就会在网络中进行发送, 在到达服务器之前需要经过交换机和路由.

交换机会根据MAC Header进行转发, 路由器会根据IP Header进行路由、转发.

报文到达服务器后会进行拆包, 并将对应的HTTP报文交给应用程序解析和处理.

## TCP可靠传输

### 超时重传

* 触发条件: 重传定时器超时.
* 阈值 = 拥塞窗口 / 2
* 拥塞窗口 = 1

### 快速重传

* 触发条件: 收到3个重复Ack.
* 阈值 = 拥塞窗口 / 2
* 拥塞窗口 = 拥塞窗口 / 2

## TCP拥塞控制

### 慢启动

* 条件: 拥塞窗口小于阈值.
* 拥塞窗口大小随时间成指数式增长.

### 拥塞避免

* 条件: 拥塞窗口大于阈值.
* 拥塞窗口大小随时间线性增长.

## TCP四次挥手

![TCP Close](https://img.axlis.cn/note/Java/TCP-Close.png)

Q: 服务器出现大量Time Wait状态的原因?

* HTTP短连接.
* HTTP长连接超时.
* HTTP长连接请求数达到上限.
